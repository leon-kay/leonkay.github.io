<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æƒ…ç»ªä¼ æŸ“æ¸¸æˆ - ä¼˜åŒ–ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: radial-gradient(ellipse at top, #667eea 0%, #764ba2 50%, #2c3e50 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
            position: relative;
        }

        /* åŠ¨æ€æ˜Ÿç©ºèƒŒæ™¯ */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(2px 2px at 20px 30px, #fff, transparent),
                radial-gradient(2px 2px at 40px 70px, rgba(255,255,255,0.8), transparent),
                radial-gradient(1px 1px at 90px 40px, #fff, transparent),
                radial-gradient(1px 1px at 130px 80px, rgba(255,255,255,0.6), transparent),
                radial-gradient(2px 2px at 160px 30px, #fff, transparent);
            background-repeat: repeat;
            background-size: 200px 150px;
            animation: starMove 60s linear infinite;
            opacity: 0.4;
            z-index: -1;
        }

        @keyframes starMove {
            0% { background-position: 0 0; }
            100% { background-position: 200px 150px; }
        }

        .game-container {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 25px;
            padding: 30px;
            box-shadow: 
                0 25px 50px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 25px;
        }

        .header h1 {
            font-size: 36px;
            margin: 0 0 15px 0;
            text-shadow: 0 3px 15px rgba(0,0,0,0.4);
            background: linear-gradient(45deg, #FFD700, #FFA500, #FF69B4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 3s ease-in-out infinite alternate;
        }

        @keyframes titleGlow {
            0% { filter: brightness(1); }
            100% { filter: brightness(1.2); }
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            font-size: 18px;
            text-align: center;
        }

        .emotion-meter {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .meter-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .meter-bar {
            width: 8px;
            height: 60px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .meter-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            transition: height 0.5s ease;
            border-radius: 4px;
        }

        .meter-fill.happy { background: linear-gradient(to top, #FFD700, #FFA500); }
        .meter-fill.sad { background: linear-gradient(to top, #87CEEB, #4682B4); }
        .meter-fill.angry { background: linear-gradient(to top, #FF6B6B, #DC143C); }
        .meter-fill.neutral { background: linear-gradient(to top, #D3D3D3, #A9A9A9); }

        .grid {
            display: grid;
            gap: 8px;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 20px;
            margin: 25px 0;
            box-shadow: inset 0 5px 15px rgba(0,0,0,0.3);
        }

        .cell {
            width: 65px;
            height: 65px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border: 3px solid transparent;
            position: relative;
            overflow: visible;
            animation: breathe 4s ease-in-out infinite;
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1) translateY(0); }
            50% { transform: scale(1.03) translateY(-2px); }
        }

        .cell.happy {
            background: radial-gradient(circle, #FFD700, #FFA500);
            box-shadow: 
                0 0 25px rgba(255, 215, 0, 0.7),
                0 5px 15px rgba(0,0,0,0.3);
            animation: breathe 4s ease-in-out infinite, happyGlow 3s ease-in-out infinite alternate;
        }

        @keyframes happyGlow {
            0% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.7), 0 5px 15px rgba(0,0,0,0.3); }
            100% { box-shadow: 0 0 35px rgba(255, 215, 0, 0.9), 0 5px 20px rgba(0,0,0,0.4); }
        }

        .cell.sad {
            background: radial-gradient(circle, #87CEEB, #4682B4);
            box-shadow: 
                0 0 25px rgba(70, 130, 180, 0.7),
                0 5px 15px rgba(0,0,0,0.3);
            animation: breathe 4s ease-in-out infinite, sadSway 6s ease-in-out infinite alternate;
        }

        @keyframes sadSway {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(-2deg); }
        }

        .cell.angry {
            background: radial-gradient(circle, #FF6B6B, #DC143C);
            box-shadow: 
                0 0 25px rgba(220, 20, 60, 0.7),
                0 5px 15px rgba(0,0,0,0.3);
            animation: breathe 4s ease-in-out infinite, angryShake 1s ease-in-out infinite;
        }

        @keyframes angryShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-1px); }
            75% { transform: translateX(1px); }
        }

        .cell.neutral {
            background: radial-gradient(circle, #D3D3D3, #A9A9A9);
            box-shadow: 
                0 0 20px rgba(169, 169, 169, 0.4),
                0 5px 15px rgba(0,0,0,0.3);
        }

        .cell:hover:not(.chain-reaction) {
            transform: scale(1.15) translateY(-3px);
            box-shadow: 
                0 0 40px rgba(255, 255, 255, 0.8),
                0 10px 25px rgba(0,0,0,0.4);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .cell.spreading {
            animation: spreadEffect 0.8s ease-out;
            z-index: 5;
        }

        @keyframes spreadEffect {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.8);
            }
            50% {
                transform: scale(1.3);
                box-shadow: 0 0 0 20px rgba(255, 255, 255, 0.3);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 40px rgba(255, 255, 255, 0);
            }
        }

        .cell.chain-reaction {
            animation: 
                explosion 1.2s ease-out,
                firework 1.2s ease-out,
                slowMotion 0.5s ease-in-out;
            z-index: 10;
            filter: brightness(1.5);
        }

        @keyframes explosion {
            0% { transform: scale(1); }
            30% { transform: scale(1.5); }
            70% { transform: scale(0.8); }
            100% { transform: scale(1); }
        }

        @keyframes firework {
            0% {
                box-shadow:
                    0 0 15px 5px rgba(255, 215, 0, 1),
                    0 0 30px 10px rgba(255, 140, 0, 0.8),
                    0 0 45px 15px rgba(255, 69, 180, 0.6),
                    0 0 60px 20px rgba(138, 43, 226, 0.4);
            }
            100% {
                box-shadow:
                    0 0 5px 1px rgba(255, 215, 0, 0.2),
                    0 0 10px 3px rgba(255, 140, 0, 0.1),
                    0 0 15px 5px rgba(255, 69, 180, 0.05),
                    0 0 20px 8px rgba(138, 43, 226, 0);
            }
        }

        .cell.power-up {
            border: 3px solid gold;
            box-shadow: 0 0 30px gold;
            animation: powerPulse 1s ease-in-out infinite;
        }

        @keyframes powerPulse {
            0%, 100% { transform: scale(1); border-color: gold; }
            50% { transform: scale(1.1); border-color: orange; }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 25px 0;
            flex-wrap: wrap;
        }

        .tool {
            background: rgba(255,255,255,0.25);
            border: 2px solid rgba(255,255,255,0.4);
            color: white;
            padding: 15px 25px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
            overflow: hidden;
        }

        .tool::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s ease;
        }

        .tool:hover::before {
            left: 100%;
        }

        .tool:hover:not(.disabled) {
            background: rgba(255,255,255,0.35);
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }

        .tool.active {
            background: rgba(255,215,0,0.4);
            border-color: #FFD700;
            animation: toolBounce 1.5s ease-in-out infinite;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
        }

        @keyframes toolBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .tool.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 25px 0;
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .game-status {
            text-align: center;
            margin: 25px 0;
            font-size: 18px;
            min-height: 30px;
            font-weight: bold;
        }

        .level-complete {
            background: linear-gradient(45deg, rgba(0,255,0,0.3), rgba(0,255,150,0.3));
            border: 2px solid #00ff96;
            border-radius: 20px;
            padding: 25px;
            margin: 25px 0;
            text-align: center;
            animation: completeGlow 2s ease-in-out infinite alternate;
        }

        @keyframes completeGlow {
            0% { box-shadow: 0 0 20px rgba(0, 255, 150, 0.5); }
            100% { box-shadow: 0 0 40px rgba(0, 255, 150, 0.8); }
        }

        .instructions {
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
            font-size: 14px;
            line-height: 1.6;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .chain-indicator {
            position: absolute;
            top: -8px;
            right: -8px;
            background: linear-gradient(45deg, gold, orange);
            color: black;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: indicatorPulse 1s ease-in-out infinite;
            box-shadow: 0 2px 10px rgba(255, 215, 0, 0.7);
        }

        @keyframes indicatorPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .success-particle {
            position: absolute;
            pointer-events: none;
            font-size: 20px;
            animation: floatUp 1s ease-out forwards;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px) scale(1.5);
            }
        }

        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 768px) {
            body { padding: 10px; }
            .game-container { padding: 20px; }
            .cell { width: 50px; height: 50px; font-size: 32px; }
            .header h1 { font-size: 28px; }
            .controls { gap: 10px; }
            .tool { padding: 12px 20px; font-size: 14px; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>æƒ…ç»ªä¼ æŸ“æ¸¸æˆ ğŸ§ ğŸ’­</h1>
            <div class="instructions">
                <strong>æ¸¸æˆè§„åˆ™ï¼š</strong> ä½¿ç”¨å·¥å…·æ”¹å˜å°äººæƒ…ç»ªï¼Œè®©æƒ…ç»ªä¼ æ’­ï¼Œç›®æ ‡æ˜¯è®©æ‰€æœ‰å°äººéƒ½å˜å¼€å¿ƒï¼<br>
                <strong>ä¼ æ’­è§„åˆ™ï¼š</strong> ğŸ˜Šæ„ŸæŸ“ğŸ˜¢â†’ğŸ˜Š | ğŸ˜¡æ„ŸæŸ“ğŸ˜¢â†’ğŸ˜¡ | ğŸ˜Š+ğŸ˜¡â†’ğŸ˜ | ğŸ˜Šæ„ŸæŸ“ğŸ˜â†’ğŸ˜Š<br>
                <strong>è¿é”ååº”ï¼š</strong> 4ä¸ªç›¸åŒæƒ…ç»ªå½¢æˆæ–¹å—æ—¶ä¼šäº§ç”Ÿçˆ†ç‚¸æ•ˆåº”ï¼Œå½±å“æ›´å¤§èŒƒå›´ï¼
            </div>
        </div>

        <div class="game-info">
            <div>å…³å¡: <span id="currentLevel">1</span>/2</div>
            <div>æ­¥æ•°: <span id="stepCount">0</span></div>
            <div>çŠ¶æ€: <span id="gameStatus">é€‰æ‹©å·¥å…·å¼€å§‹</span></div>
        </div>

        <div class="emotion-meter">
            <div class="meter-item">
                <div>ğŸ˜Š</div>
                <div class="meter-bar">
                    <div class="meter-fill happy" id="happyMeter"></div>
                </div>
                <div id="happyCount">0</div>
            </div>
            <div class="meter-item">
                <div>ğŸ˜¢</div>
                <div class="meter-bar">
                    <div class="meter-fill sad" id="sadMeter"></div>
                </div>
                <div id="sadCount">0</div>
            </div>
            <div class="meter-item">
                <div>ğŸ˜¡</div>
                <div class="meter-bar">
                    <div class="meter-fill angry" id="angryMeter"></div>
                </div>
                <div id="angryCount">0</div>
            </div>
            <div class="meter-item">
                <div>ğŸ˜</div>
                <div class="meter-bar">
                    <div class="meter-fill neutral" id="neutralMeter"></div>
                </div>
                <div id="neutralCount">0</div>
            </div>
        </div>

        <div class="grid" id="gameGrid"></div>

        <div class="controls">
            <div class="tool" id="happyTool" data-tool="happy">ğŸ’‰ å¿«ä¹é’ˆç­’ (<span id="happyToolCount">3</span>)</div>
            <div class="tool" id="calmTool" data-tool="calm">ğŸ§Š å†·é™å‰‚ (<span id="calmToolCount">2</span>)</div>
            <div class="tool" id="clearTool" data-tool="clear">âŒ å–æ¶ˆé€‰æ‹©</div>
        </div>

        <div class="action-buttons">
            <button class="btn" id="spreadBtn" onclick="spreadEmotions()">ğŸŒŠ æƒ…ç»ªä¼ æ’­</button>
            <button class="btn" id="resetBtn" onclick="resetLevel()">ğŸ”„ é‡ç½®å…³å¡</button>
            <button class="btn" id="nextBtn" onclick="nextLevel()" style="display:none;">â¡ï¸ ä¸‹ä¸€å…³</button>
        </div>

        <div class="game-status" id="statusMessage"></div>
    </div>

    <script>
        // æ¸¸æˆçŠ¶æ€
        let currentLevel = 1;
        let stepCount = 0;
        let selectedTool = null;
        let gameWon = false;
        let tools = { happy: 3, calm: 2 };

        // å…³å¡é…ç½®
        const levels = {
            1: {
                size: 4,
                grid: [
                    ['sad', 'sad', 'happy', 'sad'],
                    ['angry', 'sad', 'sad', 'neutral'],
                    ['sad', 'angry', 'neutral', 'sad'],
                    ['neutral', 'sad', 'sad', 'happy']
                ],
                tools: { happy: 3, calm: 2 }
            },
            2: {
                size: 5,
                grid: [
                    ['angry', 'sad', 'neutral', 'sad', 'angry'],
                    ['sad', 'angry', 'sad', 'angry', 'sad'],
                    ['neutral', 'sad', 'happy', 'sad', 'neutral'],
                    ['sad', 'angry', 'sad', 'angry', 'sad'],
                    ['angry', 'sad', 'neutral', 'sad', 'angry']
                ],
                tools: { happy: 4, calm: 3 }
            }
        };

        let gameGrid = [];

        // è¡¨æƒ…æ˜ å°„
        const emotions = {
            'happy': 'ğŸ˜Š',
            'sad': 'ğŸ˜¢',
            'angry': 'ğŸ˜¡',
            'neutral': 'ğŸ˜'
        };

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            const level = levels[currentLevel];
            const gridElement = document.getElementById('gameGrid');
            
            gameGrid = level.grid.map(row => [...row]);
            tools = { ...level.tools };
            stepCount = 0;
            gameWon = false;
            selectedTool = null;

            // è®¾ç½®ç½‘æ ¼
            gridElement.style.gridTemplateColumns = `repeat(${level.size}, 1fr)`;
            gridElement.innerHTML = '';

            // åˆ›å»ºæ ¼å­
            for (let i = 0; i < level.size; i++) {
                for (let j = 0; j < level.size; j++) {
                    const cell = document.createElement('div');
                    cell.className = `cell ${gameGrid[i][j]}`;
                    cell.textContent = emotions[gameGrid[i][j]];
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.onclick = () => useToolOnCell(i, j);
                    gridElement.appendChild(cell);
                }
            }

            updateUI();
            updateEmotionMeter();
        }

        // æ›´æ–°æƒ…ç»ªä»ªè¡¨ç›˜
        function updateEmotionMeter() {
            const counts = { happy: 0, sad: 0, angry: 0, neutral: 0 };
            const total = gameGrid.length * gameGrid[0].length;

            gameGrid.forEach(row => {
                row.forEach(cell => {
                    counts[cell]++;
                });
            });

            Object.keys(counts).forEach(emotion => {
                const percentage = (counts[emotion] / total) * 100;
                document.getElementById(`${emotion}Meter`).style.height = `${percentage}%`;
                document.getElementById(`${emotion}Count`).textContent = counts[emotion];
            });
        }

        // æ›´æ–°UI
        function updateUI() {
            document.getElementById('currentLevel').textContent = currentLevel;
            document.getElementById('stepCount').textContent = stepCount;
            document.getElementById('happyToolCount').textContent = tools.happy;
            document.getElementById('calmToolCount').textContent = tools.calm;

            // æ›´æ–°å·¥å…·çŠ¶æ€
            document.getElementById('happyTool').classList.toggle('disabled', tools.happy <= 0);
            document.getElementById('calmTool').classList.toggle('disabled', tools.calm <= 0);

            // æ›´æ–°é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.tool').forEach(tool => {
                tool.classList.remove('active');
            });
            if (selectedTool) {
                document.getElementById(selectedTool + 'Tool').classList.add('active');
            }

            checkWinCondition();
        }

        // å·¥å…·é€‰æ‹©
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('tool') || e.target.parentElement.classList.contains('tool')) {
                const toolElement = e.target.classList.contains('tool') ? e.target : e.target.parentElement;
                const tool = toolElement.dataset.tool;
                
                if (tool === 'clear') {
                    selectedTool = null;
                } else if (tool === 'happy' && tools.happy > 0) {
                    selectedTool = 'happy';
                } else if (tool === 'calm' && tools.calm > 0) {
                    selectedTool = 'calm';
                }
                
                updateUI();
                updateStatus();
            }
        });

        // åœ¨æ ¼å­ä¸Šä½¿ç”¨å·¥å…·
        function useToolOnCell(row, col) {
            if (!selectedTool || gameWon) return;

            const currentEmotion = gameGrid[row][col];
            let newEmotion = currentEmotion;

            if (selectedTool === 'happy') {
                newEmotion = 'happy';
                tools.happy--;
                createSuccessParticle(row, col, 'âœ¨');
            } else if (selectedTool === 'calm' && currentEmotion === 'angry') {
                newEmotion = 'neutral';
                tools.calm--;
                createSuccessParticle(row, col, 'â„ï¸');
            } else if (selectedTool === 'calm' && currentEmotion !== 'angry') {
                updateStatus('å†·é™å‰‚åªèƒ½ç”¨äºç”Ÿæ°”çš„å°äººï¼');
                return;
            }

            if (newEmotion !== currentEmotion) {
                gameGrid[row][col] = newEmotion;
                updateCell(row, col);
                stepCount++;
                selectedTool = null;
                updateUI();
                updateEmotionMeter();
                updateStatus('å·¥å…·ä½¿ç”¨æˆåŠŸï¼ç‚¹å‡»"æƒ…ç»ªä¼ æ’­"æŒ‰é’®ç»§ç»­ã€‚');
            }
        }

        // åˆ›å»ºæˆåŠŸç²’å­æ•ˆæœ
        function createSuccessParticle(row, col, emoji) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const particle = document.createElement('div');
            particle.className = 'success-particle';
            particle.textContent = emoji;
            particle.style.left = '50%';
            particle.style.top = '50%';
            particle.style.transform = 'translate(-50%, -50%)';
            cell.appendChild(particle);

            setTimeout(() => particle.remove(), 1000);
        }

        // æ›´æ–°å•ä¸ªæ ¼å­
        function updateCell(row, col) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const emotion = gameGrid[row][col];
            cell.className = `cell ${emotion}`;
            cell.textContent = emotions[emotion];
        }

        // æƒ…ç»ªä¼ æ’­
        function spreadEmotions() {
            if (gameWon) return;

            const newGrid = gameGrid.map(row => [...row]);
            const size = gameGrid.length;
            const spreadCells = [];

            // ä¼ æ’­è§„åˆ™
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const current = gameGrid[i][j];
                    const neighbors = getNeighbors(i, j, size);

                    for (const [ni, nj] of neighbors) {
                        const neighbor = gameGrid[ni][nj];
                        let newEmotion = applyEmotionRule(current, neighbor);
                        
                        if (newEmotion !== neighbor) {
                            newGrid[ni][nj] = newEmotion;
                            spreadCells.push([ni, nj]);
                        }
                    }
                }
            }

            // åº”ç”¨å˜åŒ–å¹¶æ˜¾ç¤ºä¼ æ’­æ•ˆæœ
            gameGrid = newGrid;
            showSpreadEffect(spreadCells);

            // æ£€æŸ¥è¿é”ååº”
            setTimeout(() => {
                checkChainReaction();
                updateAllCells();
                updateEmotionMeter();
                updateUI();
            }, 800);
        }

        // è·å–é‚»å±…æ ¼å­
        function getNeighbors(row, col, size) {
            const neighbors = [];
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            
            for (const [dr, dc] of directions) {
                const nr = row + dr;
                const nc = col + dc;
                if (nr >= 0 && nr < size && nc >= 0 && nc < size) {
                    neighbors.push([nr, nc]);
                }
            }
            return neighbors;
        }

        // åº”ç”¨æƒ…ç»ªè§„åˆ™
        function applyEmotionRule(source, target) {
            if (source === 'happy' && target === 'sad') return 'happy';
            if (source === 'happy' && target === 'neutral') return 'happy';
            if (source === 'angry' && target === 'sad') return 'angry';
            if (source === 'angry' && target === 'neutral') return 'sad';
                        if (source === 'happy' && target === 'angry') return 'neutral';
            if (source === 'angry' && target === 'happy') return 'neutral';
            return target;
        }

        // æ˜¾ç¤ºä¼ æ’­æ•ˆæœ
        function showSpreadEffect(cells) {
            cells.forEach(([row, col]) => {
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                cell.classList.add('spreading');
                setTimeout(() => cell.classList.remove('spreading'), 800);
            });
        }

        // æ£€æŸ¥è¿é”ååº”
        function checkChainReaction() {
            const size = gameGrid.length;
            const chainReactions = [];

            for (let i = 0; i < size - 1; i++) {
                for (let j = 0; j < size - 1; j++) {
                    const topLeft = gameGrid[i][j];
                    const topRight = gameGrid[i][j + 1];
                    const bottomLeft = gameGrid[i + 1][j];
                    const bottomRight = gameGrid[i + 1][j + 1];

                    if (topLeft === topRight && topLeft === bottomLeft && topLeft === bottomRight && topLeft !== 'neutral') {
                        chainReactions.push([
                            [i, j], [i, j + 1], [i + 1, j], [i + 1, j + 1]
                        ]);
                    }
                }
            }

            if (chainReactions.length > 0) {
                executeChainReaction(chainReactions);
                updateStatus(`ğŸ’¥ å‘ç”Ÿäº†${chainReactions.length}ä¸ªè¿é”ååº”ï¼`);
                
                // éœ‡åŠ¨æ•ˆæœï¼ˆç§»åŠ¨ç«¯ï¼‰
                if (navigator.vibrate) {
                    navigator.vibrate([100, 50, 100]);
                }
            }
        }

        // æ‰§è¡Œè¿é”ååº”
        function executeChainReaction(reactions) {
            reactions.forEach((reaction, index) => {
                setTimeout(() => {
                    const centerEmotion = gameGrid[reaction[0][0]][reaction[0][1]];
                    
                    // æ˜¾ç¤ºçˆ†ç‚¸æ•ˆæœ
                    reaction.forEach(([row, col]) => {
                        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                        cell.classList.add('chain-reaction');
                        
                        // æ·»åŠ è¿é”æŒ‡ç¤ºå™¨
                        const indicator = document.createElement('div');
                        indicator.className = 'chain-indicator';
                        indicator.textContent = 'ğŸ’¥';
                        cell.appendChild(indicator);
                        
                        setTimeout(() => {
                            cell.classList.remove('chain-reaction');
                            if (indicator.parentNode) {
                                indicator.remove();
                            }
                        }, 1200);
                    });

                    // å½±å“å‘¨å›´æ›´å¤§èŒƒå›´
                    const centerRow = reaction[0][0];
                    const centerCol = reaction[0][1];
                    const size = gameGrid.length;

                    setTimeout(() => {
                        for (let i = Math.max(0, centerRow - 1); i <= Math.min(size - 1, centerRow + 2); i++) {
                            for (let j = Math.max(0, centerCol - 1); j <= Math.min(size - 1, centerCol + 2); j++) {
                                if (gameGrid[i][j] !== centerEmotion) {
                                    const oldEmotion = gameGrid[i][j];
                                    gameGrid[i][j] = applyEmotionRule(centerEmotion, gameGrid[i][j]);
                                    
                                    if (gameGrid[i][j] !== oldEmotion) {
                                        const cell = document.querySelector(`[data-row="${i}"][data-col="${j}"]`);
                                        cell.classList.add('power-up');
                                        setTimeout(() => cell.classList.remove('power-up'), 1000);
                                    }
                                }
                            }
                        }
                        updateAllCells();
                        updateEmotionMeter();
                    }, 300);
                }, index * 200);
            });
        }

        // æ›´æ–°æ‰€æœ‰æ ¼å­
        function updateAllCells() {
            const size = gameGrid.length;
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    updateCell(i, j);
                }
            }
        }

        // æ£€æŸ¥èƒœåˆ©æ¡ä»¶
        function checkWinCondition() {
            const allHappy = gameGrid.every(row => row.every(cell => cell === 'happy'));
            
            if (allHappy && !gameWon) {
                gameWon = true;
                
                // èƒœåˆ©åŠ¨ç”»
                setTimeout(() => {
                    document.querySelectorAll('.cell').forEach((cell, index) => {
                        setTimeout(() => {
                            cell.style.animation = 'celebration 1s ease-in-out';
                        }, index * 50);
                    });
                }, 500);
                
                document.getElementById('statusMessage').innerHTML = 
                    '<div class="level-complete">ğŸ‰ å…³å¡å®Œæˆï¼æ‰€æœ‰å°äººéƒ½å¾ˆå¼€å¿ƒï¼</div>';
                
                if (currentLevel < 2) {
                    document.getElementById('nextBtn').style.display = 'inline-block';
                } else {
                    document.getElementById('statusMessage').innerHTML += 
                        '<div style="margin-top: 15px; color: gold; font-size: 20px;">ğŸ† æ­å–œä½ å®Œæˆäº†æ‰€æœ‰å…³å¡ï¼ä½ æ˜¯æƒ…ç»ªä¼ æŸ“å¤§å¸ˆï¼</div>';
                }

                // åº†ç¥éŸ³æ•ˆï¼ˆå¦‚æœæ”¯æŒï¼‰
                playSuccessSound();
            }
        }

        // æ’­æ”¾æˆåŠŸéŸ³æ•ˆ
        function playSuccessSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) {
                // éŸ³æ•ˆæ’­æ”¾å¤±è´¥æ—¶é™é»˜å¤„ç†
            }
        }

        // åº†ç¥åŠ¨ç”»
        const celebrationStyle = document.createElement('style');
        celebrationStyle.textContent = `
            @keyframes celebration {
                0%, 100% { transform: scale(1) rotate(0deg); }
                25% { transform: scale(1.2) rotate(-10deg); }
                50% { transform: scale(1.3) rotate(10deg); }
                75% { transform: scale(1.1) rotate(-5deg); }
            }
        `;
        document.head.appendChild(celebrationStyle);

        // æ›´æ–°çŠ¶æ€æ¶ˆæ¯
        function updateStatus(message = '') {
            if (message) {
                document.getElementById('gameStatus').textContent = message;
                
                // æ¶ˆæ¯è‡ªåŠ¨æ¶ˆå¤±
                setTimeout(() => {
                    if (!gameWon) {
                        updateStatus();
                    }
                }, 3000);
            } else if (selectedTool) {
                document.getElementById('gameStatus').textContent = `å·²é€‰æ‹©ï¼š${selectedTool === 'happy' ? 'å¿«ä¹é’ˆç­’ğŸ’‰' : 'å†·é™å‰‚ğŸ§Š'}ï¼Œç‚¹å‡»æ ¼å­ä½¿ç”¨`;
            } else {
                document.getElementById('gameStatus').textContent = 'é€‰æ‹©å·¥å…·å¼€å§‹æ¸¸æˆ';
            }
        }

        // é‡ç½®å…³å¡
        function resetLevel() {
            // é‡ç½®åŠ¨ç”»
            document.querySelectorAll('.cell').forEach(cell => {
                cell.style.animation = '';
                cell.classList.remove('chain-reaction', 'power-up', 'spreading');
            });
            
            initGame();
            updateStatus('å…³å¡å·²é‡ç½®ï¼Œé‡æ–°å¼€å§‹ï¼');
        }

        // ä¸‹ä¸€å…³
        function nextLevel() {
            if (currentLevel < 2) {
                currentLevel++;
                document.getElementById('nextBtn').style.display = 'none';
                
                // å…³å¡åˆ‡æ¢åŠ¨ç”»
                const container = document.querySelector('.game-container');
                container.style.transform = 'scale(0.9)';
                container.style.opacity = '0.7';
                
                setTimeout(() => {
                    initGame();
                    container.style.transform = 'scale(1)';
                    container.style.opacity = '1';
                    updateStatus(`æ¬¢è¿æ¥åˆ°ç¬¬${currentLevel}å…³ï¼éš¾åº¦å‡çº§äº†ï¼`);
                }, 300);
            }
        }

        // é”®ç›˜å¿«æ·é”®æ”¯æŒ
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case '1':
                    if (tools.happy > 0) {
                        selectedTool = 'happy';
                        updateUI();
                        updateStatus();
                    }
                    break;
                case '2':
                    if (tools.calm > 0) {
                        selectedTool = 'calm';
                        updateUI();
                        updateStatus();
                    }
                    break;
                case 'Escape':
                case '0':
                    selectedTool = null;
                    updateUI();
                    updateStatus();
                    break;
                case ' ':
                    e.preventDefault();
                    spreadEmotions();
                    break;
                case 'r':
                case 'R':
                    resetLevel();
                    break;
            }
        });

        // è§¦æ‘¸è®¾å¤‡ä¼˜åŒ–
        if ('ontouchstart' in window) {
            document.addEventListener('touchstart', function() {}, {passive: true});
            
            // é˜²æ­¢åŒå‡»ç¼©æ”¾
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function (event) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
        }

        // é¡µé¢å¯è§æ€§å˜åŒ–æ—¶æš‚åœåŠ¨ç”»
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.style.animationPlayState = 'paused';
                });
            } else {
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.style.animationPlayState = 'running';
                });
            }
        });

        // åˆå§‹åŒ–æ¸¸æˆ
        initGame();
        updateStatus();

        // æ˜¾ç¤ºé”®ç›˜å¿«æ·é”®æç¤º
        setTimeout(() => {
            if (!('ontouchstart' in window)) {
                updateStatus('ğŸ’¡ æç¤ºï¼šå¯ä½¿ç”¨é”®ç›˜å¿«æ·é”® 1(å¿«ä¹) 2(å†·é™) 0(å–æ¶ˆ) ç©ºæ ¼(ä¼ æ’­) R(é‡ç½®)');
            }
        }, 2000);
    </script>
</body>
</html>
